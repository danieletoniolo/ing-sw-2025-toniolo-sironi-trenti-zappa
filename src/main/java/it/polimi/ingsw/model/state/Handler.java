package it.polimi.ingsw.model.state;

import it.polimi.ingsw.event.game.serverToClient.dice.DiceRolled;
import it.polimi.ingsw.event.game.serverToClient.energyUsed.BatteriesLoss;
import it.polimi.ingsw.event.game.serverToClient.goods.UpdateGoodsExchange;
import it.polimi.ingsw.event.game.serverToClient.pickedTile.*;
import it.polimi.ingsw.event.game.serverToClient.placedTile.PlacedTileToSpaceship;
import it.polimi.ingsw.event.game.serverToClient.spaceship.*;
import it.polimi.ingsw.event.type.Event;
import it.polimi.ingsw.model.game.board.Level;
import it.polimi.ingsw.model.good.Good;
import it.polimi.ingsw.model.good.GoodType;
import it.polimi.ingsw.model.player.PlayerData;
import it.polimi.ingsw.model.spaceship.*;
import it.polimi.ingsw.model.state.utils.MutablePair;
import org.javatuples.Pair;
import org.javatuples.Triplet;

import java.util.*;

/**
 * Handler class to manage the actions related to the {@link State} of the game.
 * This class contains static methods we are used by multiple {@link State} in order to organize the code better
 * and avoid code duplication.
 * @author Daniele Toniolo
 */
public class Handler {

    /**
     * Handles the protection mechanism when a component is hit during combat.
     * This method manages the logic for either using energy from a battery to protect
     * a component or destroying the component if protection fails or is not available.
     *
     * @param player The player whose spaceship is being affected
     * @param protectionResult A pair containing the component being hit and the protection type:
     *                        - 0: No protection available, component will be destroyed
     *                        - -1: Protection failed, component will be destroyed
     *                        - Other values: Protection successful
     * @param batteryID The ID of the battery to use for protection, or -1 if no battery is used
     * @return A list of events generated by the protection action, or null if protection was successful
     */
    static List<Event> protectFromHit(PlayerData player, MutablePair<Component, Integer> protectionResult, int batteryID) {
        SpaceShip ship = player.getSpaceShip();
        Component component = protectionResult.getFirst();
        int protectionType = protectionResult.getSecond();
        ArrayList<Event> events = new ArrayList<>();

        if (protectionType == 0 || protectionType == -1) {
            if (batteryID != -1 && protectionType != -1) {
                ship.useEnergy(batteryID);
                events.add(new BatteriesLoss(player.getUsername(), new ArrayList<>(Arrays.asList(new Pair<>(batteryID, ship.getBattery(batteryID).getEnergyNumber())))));
            } else {
                ship.destroyComponent(component.getRow(), component.getColumn());

                if (component.getComponentType() == ComponentType.SINGLE_ENGINE ||
                    component.getComponentType() == ComponentType.DOUBLE_ENGINE ||
                    component.getComponentType() == ComponentType.CABIN) {
                    SetEngineStrength engineStrength = new SetEngineStrength(player.getUsername(), ship.getDefaultEnginesStrength(), ship.getMaxEnginesStrength());
                    events.add(engineStrength);
                }
                if (component.getComponentType() == ComponentType.SINGLE_CANNON ||
                    component.getComponentType() == ComponentType.DOUBLE_CANNON ||
                    component.getComponentType() == ComponentType.CABIN) {
                    SetCannonStrength cannonStrength = new SetCannonStrength(player.getUsername(), ship.getDefaultCannonsStrength(), ship.getMaxCannonsStrength());
                    events.add(cannonStrength);
                }

                ArrayList<Pair<Integer, Integer>> destroyedComponents = new ArrayList<>();
                destroyedComponents.add(new Pair<>(component.getRow(), component.getColumn()));
                events.add(new ComponentDestroyed(player.getUsername(), destroyedComponents));
            }
            return events;
        }
        return null;
    }

    /**
     * Checks for disconnected component fragments in the player's spaceship and adds them to the provided fragments list.
     * This method retrieves all disconnected components from the spaceship and combines them with any existing fragments,
     * then creates a Fragments event to notify about the disconnected components.
     *
     * @param player The player whose spaceship is being checked for fragments
     * @param fragments A list of existing fragment groups to which new disconnected components will be added.
     *                 Each inner list represents a group of connected components that have become disconnected.
     * @return A Fragments event containing all the fragment groups (existing + newly found disconnected components)
     */
    static Event checkForFragments(PlayerData player, List<List<Pair<Integer, Integer>>> fragments) {
        SpaceShip ship = player.getSpaceShip();
        fragments.addAll(ship.getDisconnectedComponents());
        return new Fragments(player.getUsername(), fragments);
    }

    /**
     * Destroys a fragment of disconnected components from the player's spaceship.
     * This method removes all components in the provided fragment list and generates
     * appropriate events to notify about the destruction and any strength updates.
     *
     * @param player The player whose spaceship contains the fragment to be destroyed
     * @param fragments A list of coordinate pairs representing the components to destroy.
     *                 Each pair contains (row, column) coordinates of a component in the fragment.
     * @return A list of events generated by the fragment destruction, including:
     *         - ComponentDestroyed event for the destroyed components
     *         - SetEngineStrength event if any engines or cabins were destroyed
     *         - SetCannonStrength event if any cannons or cabins were destroyed
     */
    static List<Event> destroyFragment(PlayerData player, List<Pair<Integer, Integer>> fragments) {
        SpaceShip ship = player.getSpaceShip();
        List<Event> events = new ArrayList<>();
        boolean isEngine = false, isCannon = false;

        for (Pair<Integer, Integer> fragment : fragments) {
            Component component = ship.getComponent(fragment.getValue0(), fragment.getValue1());
            if (component.getComponentType() == ComponentType.SINGLE_ENGINE ||
                component.getComponentType() == ComponentType.DOUBLE_ENGINE ||
                component.getComponentType() == ComponentType.CABIN) {
                isEngine = true;
            } else if (component.getComponentType() == ComponentType.SINGLE_CANNON ||
                    component.getComponentType() == ComponentType.DOUBLE_CANNON ||
                    component.getComponentType() == ComponentType.CABIN) {
                isCannon = true;
            }

            ship.destroyComponent(fragment.getValue0(), fragment.getValue1());
        }

        ComponentDestroyed componentDestroyed = new ComponentDestroyed(player.getUsername(), fragments);
        events.add(componentDestroyed);

        if (isEngine) {
            SetEngineStrength engineStrength = new SetEngineStrength(player.getUsername(), ship.getDefaultEnginesStrength(), ship.getMaxEnginesStrength());
            events.add(engineStrength);
        }
        if (isCannon) {
            SetCannonStrength cannonStrength = new SetCannonStrength(player.getUsername(), ship.getDefaultCannonsStrength(), ship.getMaxCannonsStrength());
            events.add(cannonStrength);
        }

        return events;
    }

    /**
     * Rolls two dice and updates the provided dice pair with the results.
     * Each die produces a random value between 1 and 6 (inclusive).
     *
     * @param player The player who is rolling the dice
     * @param dice A mutable pair that will be updated with the rolled values
     * @return A DiceRolled event containing the player's username and both dice values
     */
    static Event rollDice(PlayerData player, MutablePair<Integer, Integer> dice) {
        int firstDice = (int) (Math.random() * 6) + 1;
        int secondDice = (int) (Math.random() * 6) + 1;
        dice.setFirst(firstDice);
        dice.setSecond(secondDice);

        return new DiceRolled(player.getUsername(), firstDice, secondDice);
    }

    /**
     * Uses extra energy from batteries to enhance the strength of cannons or engines.
     * This method validates that the specified components exist, checks if batteries have sufficient energy,
     * consumes the required energy, and returns an event indicating the battery usage.
     *
     * @param player The player whose spaceship components will be enhanced
     * @param type The type of component to enhance:
     *             - 0: Engines
     *             - 1: Cannons
     * @param cannonsOrEnginesID List of component IDs to enhance (engines or cannons based on type)
     * @param batteriesID List of battery IDs to use for providing extra energy
     * @return A BatteriesLoss event indicating the energy consumption from batteries
     * @throws IllegalStateException if the number of components and batteries don't match,
     *                              if any battery doesn't have enough energy,
     *                              or if any component ID is invalid
     */
    static Event useExtraStrength(PlayerData player, int type, List<Integer> cannonsOrEnginesID, List<Integer> batteriesID) throws IllegalStateException {
        if (cannonsOrEnginesID.size() != batteriesID.size()) {
            throw new IllegalStateException("The number of cannons and batteries must be the same");
        }
        SpaceShip ship = player.getSpaceShip();
        Map<Integer, Integer> batteriesMap = new HashMap<>();
        for (int batteryID : batteriesID) {
            batteriesMap.merge(batteryID, 1, Integer::sum);
        }
        for (int batteryID : batteriesMap.keySet()) {
            if (ship.getBattery(batteryID).getEnergyNumber() < batteriesMap.get(batteryID)) {
                throw new IllegalStateException("Not enough energy in battery " + batteryID);
            }
        }
        Event event = null;
        switch (type) {
            case 0 -> {
                // Check if the engines are valid
                for (int engineID : cannonsOrEnginesID) {
                    ship.getEngine(engineID);
                }
            }
            case 1 -> {
                // Check if the cannons are valid
                for (int cannonID : cannonsOrEnginesID) {
                    ship.getCannon(cannonID);
                }
            }
        }
        for (int batteryID : batteriesMap.keySet()) {
            for (int i = 0; i < batteriesMap.get(batteryID); i++) {
                ship.useEnergy(batteryID);
            }
        }

        return new BatteriesLoss(player.getUsername(), batteriesID.stream().map(t -> new Pair<>(t, ship.getBattery(t).getEnergyNumber())).toList());
    }

    /**
     * Handles the loss of goods from the player's spaceship storages.
     * This method validates that the selected goods to discard are the most valuable ones available,
     * removes them from the specified storages, and returns an event indicating the updated storage states.
     *
     * @param player The player who is losing goods from their spaceship
     * @param storagesID List of storage IDs from which goods will be removed.
     *                   Each storage ID can appear multiple times to remove multiple goods from the same storage.
     * @param requiredGoodLoss The total number of goods that must be discarded
     * @return An UpdateGoodsExchange event containing the updated state of all affected storages
     * @throws IllegalStateException if:
     *         - Not enough goods are available in the specified storages
     *         - Too few goods are selected for discard when more are available
     *         - Too many goods are selected for discard
     *         - The selected goods are not the most valuable ones available
     */
    static Event loseGoods(PlayerData player, List<Integer> storagesID, int requiredGoodLoss) throws IllegalStateException {
        Map <Integer, Integer> goodsMap = new HashMap<>();
        for (int storageID : storagesID) {
            goodsMap.merge(storageID, 1, Integer::sum);
        }
        // Check that the selected goods to discard are the most valuable
        PriorityQueue<Good> goodsToDiscardQueue = new PriorityQueue<>(Comparator.comparingInt(Good::getValue).reversed());
        for (int storageID : goodsMap.keySet()) {
            for (int i = 0; i < goodsMap.get(storageID); i++) {
                Good good = player.getSpaceShip().getStorage(storageID).peekGood(i);
                if (good == null) {
                    throw new IllegalStateException("Not enough goods in storage " + storageID);
                }
                goodsToDiscardQueue.add(good);
            }
        }
        PriorityQueue<Good> mostValuableGoods = new PriorityQueue<>(player.getSpaceShip().getGoods());

        if (goodsToDiscardQueue.size() < requiredGoodLoss && mostValuableGoods.size() < requiredGoodLoss && player.getSpaceShip().getGoods().size() >= requiredGoodLoss) {
            throw new IllegalStateException("We have not set enough goods to discard");
        }
        if (goodsToDiscardQueue.size() > requiredGoodLoss) {
            throw new IllegalStateException("We have set too many goods to discard");
        }
        for (int i = 0; i < goodsToDiscardQueue.size(); i++) {
            if (goodsToDiscardQueue.peek().getValue() != mostValuableGoods.peek().getValue()) {
                throw new IllegalStateException("The goods to discard are not the most valuable");
            }
            goodsToDiscardQueue.poll();
            mostValuableGoods.poll();
        }
        // Remove the goods from the storages
        SpaceShip ship = player.getSpaceShip();
        for (int storageID : storagesID) {
            ship.pollGood(storageID);
        }

        return new UpdateGoodsExchange(
                player.getUsername(),
                storagesID.stream()
                        .map(t -> new Pair<>(
                                t,
                                ship.getStorage(t).getGoods().stream().map(g -> g.getColor().getValue()).toList()
                        )).toList()
        );
    }

    /**
     * Handles the loss of energy from batteries in the player's spaceship.
     * This method validates that the specified batteries have sufficient energy,
     * removes the required amount of energy from them, and returns an event indicating the battery usage.
     *
     * @param player The player whose spaceship batteries will lose energy
     * @param batteriesID List of battery IDs from which energy will be removed.
     *                    Each battery ID can appear multiple times to remove multiple energy units from the same battery.
     * @param requiredBatteryLoss The total number of energy units that must be removed from batteries
     * @return A BatteriesLoss event containing the updated energy levels of all affected batteries
     * @throws IllegalStateException if:
     *         - Not enough energy is available in the specified batteries
     *         - Too few batteries are selected when more energy is available
     *         - Too many batteries are selected for energy removal
     */
    static Event loseBatteries(PlayerData player, List<Integer> batteriesID, int requiredBatteryLoss) throws IllegalStateException {
        // Check if there are the provided number of batteries in the provided batteries slots.
        Map<Integer, Integer> batteriesMap = new HashMap<>();
        for (int batteryID : batteriesID) {
            batteriesMap.merge(batteryID, 1, Integer::sum);
        }
        SpaceShip ship = player.getSpaceShip();
        for (int batteryID : batteriesMap.keySet()) {
            if (ship.getBattery(batteryID).getEnergyNumber() < batteriesMap.get(batteryID)) {
                throw new IllegalStateException("Not enough energy in battery " + batteryID);
            }
        }

        if (batteriesID.size() < requiredBatteryLoss && player.getSpaceShip().getEnergyNumber() >= requiredBatteryLoss) {
            throw new IllegalStateException("We have not set enough energy to discard");
        }
        // Check if the number of batteries to remove is equal to the number of batteries required to lose
        // The number of batteries to lose is the number of goods to discard minus the number of goods already discarded
        if (batteriesID.size() > requiredBatteryLoss) {
            throw new IllegalStateException("We have set too many batteries to discard");
        }
        // Remove the batteries from the ship
        for (int batteryID : batteriesID) {
            for (int i = 0; i < batteriesMap.get(batteryID); i++) {
                ship.useEnergy(batteryID);
            }
        }

        return new BatteriesLoss(
                player.getUsername(),
                batteriesID.stream().map(t -> new Pair<>(t, ship.getBattery(t).getEnergyNumber())).toList()
        );
    }

    /**
     * Handles the loss of crew members from cabins in the player's spaceship.
     * This method validates that the specified cabins have sufficient crew members,
     * removes the required number of crew members from them, and generates appropriate events
     * to notify about the crew loss and any strength updates caused by alien crew members.
     *
     * @param player The player whose spaceship crew members will be removed
     * @param cabinsID List of cabin IDs from which crew members will be removed.
     *                 Each cabin ID can appear multiple times to remove multiple crew members from the same cabin.
     * @param requiredCrewLoss The total number of crew members that must be removed from cabins
     * @return A list of events generated by the crew loss, including:
     *         - UpdateCrewMembers event for the updated cabin states
     *         - SetEngineStrength event if any brown aliens were lost
     *         - SetCannonStrength event if any purple aliens were lost
     * @throws IllegalStateException if:
     *         - Not enough crew members are available in the specified cabins
     *         - Too few crew members are selected when more are available
     *         - Too many crew members are selected for removal
     */
    static List<Event> loseCrew(PlayerData player, List<Integer> cabinsID, int requiredCrewLoss) throws IllegalStateException {
        // Check if there are the provided number of crew members in the provided cabins
        Map<Integer, Integer> cabinCrewMap = new HashMap<>();
        ArrayList<Event> events = new ArrayList<>();
        for (int cabinID : cabinsID) {
            cabinCrewMap.merge(cabinID, 1, Integer::sum);
        }
        SpaceShip ship = player.getSpaceShip();
        for (int cabinID : cabinCrewMap.keySet()) {
            if (ship.getCabin(cabinID).getCrewNumber() < cabinCrewMap.get(cabinID)) {
                throw new IllegalStateException("Not enough crew members in cabin " + cabinID);
            }
        }
        // Check if the number of crew members to remove is equal to the number of crew members required to lose
        if (cabinsID.size() > requiredCrewLoss) {
            throw new IllegalStateException("Too many crew members to lose");
        }
        if (cabinsID.size() < requiredCrewLoss && ship.getCrewNumber() > cabinsID.size()) {
            throw new IllegalStateException("We have not set enough crew members to lose");
        }

        boolean isBrownAlien = false, isPurpleAlien = false;
        // Remove the crew members from the cabins
        for (int cabinID : cabinCrewMap.keySet()) {
            if (ship.getCabin(cabinID).hasBrownAlien()) {
                isBrownAlien = true;
            } else if (ship.getCabin(cabinID).hasPurpleAlien()) {
                isPurpleAlien = true;
            }
            ship.removeCrewMember(cabinID, cabinCrewMap.get(cabinID));
        }
        // Convert the cabin crew map to a format expected by the event
        List<Triplet<Integer, Integer, Integer>> cabins = cabinCrewMap.keySet().stream()
                .map(cabinID -> {
                    Cabin cabin = ship.getCabin(cabinID);
                    return new Triplet<>(cabinID, cabin.getCrewNumber(), cabin.hasBrownAlien() ? 1 : cabin.hasPurpleAlien() ? 2 : 0);
                }).toList();

        if (isBrownAlien) {
            // If the player has lost a brown alien, we need to update the engine strength
            SetEngineStrength engineStrength = new SetEngineStrength(player.getUsername(), ship.getDefaultEnginesStrength(), ship.getMaxEnginesStrength());
            events.add(engineStrength);
        } else if (isPurpleAlien) {
            // If the player has lost a purple alien, we need to update the cannon strength
            SetCannonStrength cannonStrength = new SetCannonStrength(player.getUsername(), ship.getDefaultCannonsStrength(), ship.getMaxCannonsStrength());
            events.add(cannonStrength);
        }

        // Trigger the event to update the crew members
        events.add(new UpdateCrewMembers(player.getUsername(), cabins));
        return events;
    }

    /**
     * Handles the exchange of goods between the player's spaceship storages and available planet goods.
     * This method validates that all exchange operations are valid (correct storages, available goods,
     * sufficient capacity, dangerous goods handling) and then executes the exchanges.
     *
     * @param player The player performing the goods exchange
     * @param exchangeData A list of triplets, where each triplet contains:
     *                     - First element: List of goods to receive from the planet
     *                     - Second element: List of goods to give from the storage
     *                     - Third element: Storage ID where the exchange will take place
     * @param goodsReward List of goods available on the planet for exchange
     * @return An UpdateGoodsExchange event containing the updated state of all affected storages
     * @throws IllegalStateException if any validation fails during the exchange process
     * @throws IllegalArgumentException if:
     *         - Invalid storage ID is provided
     *         - Requested goods are not available on the planet
     *         - Dangerous goods are placed in non-dangerous storage
     *         - Storage doesn't have the goods to give
     *         - Storage doesn't have enough capacity for new goods
     */
    static Event exchangeGoods(PlayerData player, List<Triplet<List<Good>, List<Good>, Integer>> exchangeData, List<Good> goodsReward) throws IllegalStateException {
        SpaceShip ship = player.getSpaceShip();
        for (Triplet<List<Good>, List<Good>, Integer> triplet : exchangeData) {
            Storage storage;
            // Check that the storage exists
            try {
                storage = ship.getStorage(triplet.getValue2());
            } catch (IllegalArgumentException e) {
                throw new IllegalArgumentException("Invalid storage ID: " + triplet.getValue2());
            }
            // Check that the goods to get are in the planet selected
            for (Good good : triplet.getValue0()) {
                if (!goodsReward.contains(good)) {
                    throw new IllegalArgumentException ("The good the player want to get is not available");
                }
                // Check if there is dangerous goods
                if (good.getColor() == GoodType.RED && !storage.isDangerous()) {
                    throw new IllegalArgumentException ("The good is dangerous and the storage is not dangerous");
                }
            }
            // Check that the goods to leave are in the storage
            for (Good good : triplet.getValue1()) {
                if (!storage.hasGood(good)) {
                    throw new IllegalArgumentException ("The Good the player want to leave is not in storage " + triplet.getValue2());
                }
            }
            // Check that we can store the goods in the storage
            if (storage.getGoodsCapacity() + triplet.getValue1().size() < triplet.getValue0().size()) {
                throw new IllegalArgumentException ("The storage " + triplet.getValue2() + " does not have enough space to store the goods");
            }
        }
        // If we reach this point, the exchange data is valid so we can execute the exchange
        for (Triplet<List<Good>, List<Good>, Integer> triplet : exchangeData) {
            ship.exchangeGood(triplet.getValue0(), triplet.getValue1(), triplet.getValue2());
        }
        // Convert the exchange data to the format expected by the event and trigger the event
        List<Pair<Integer, List<Integer>>> convertedData = exchangeData.stream()
                .map(t -> new Pair<>(
                        t.getValue2(),
                        ship.getStorage(t.getValue2()).getGoods().stream()
                                .map(g -> g.getColor().getValue())
                                .toList()
                )).toList();
        return new UpdateGoodsExchange(player.getUsername(), convertedData);
    }

    /**
     * Handles the swapping of goods between two storages in the player's spaceship.
     * This method validates that both storages exist, contain the required goods to swap,
     * and have sufficient capacity for the incoming goods, then executes the swap operation.
     *
     * @param player The player whose spaceship storages will be involved in the swap
     * @param storageID1 The ID of the first storage participating in the swap
     * @param storageID2 The ID of the second storage participating in the swap
     * @param goods1to2 List of goods to move from storage1 to storage2
     * @param goods2to1 List of goods to move from storage2 to storage1
     * @return An UpdateGoodsExchange event containing the updated state of both storages after the swap
     * @throws IllegalStateException if any validation fails during the swap process
     * @throws IllegalArgumentException if:
     *         - Invalid storage IDs are provided
     *         - Either storage doesn't contain the goods to be swapped
     *         - Either storage doesn't have enough capacity for the incoming goods
     */
    static Event swapGoods(PlayerData player, int storageID1, int storageID2, List<Good> goods1to2, List<Good> goods2to1) throws IllegalStateException {
        // Check that the storage exists
        SpaceShip ship = player.getSpaceShip();
        Storage storage1, storage2;
        try {
            storage1 = ship.getStorage(storageID1);
            storage2 = ship.getStorage(storageID2);
        } catch (IllegalArgumentException e) {
            throw new IllegalArgumentException("Invalid storage ID: " + storageID1 + " or " + storageID2);
        }
        // Check that the goods to leave are in the storage 1
        for (Good good : goods1to2) {
            if (!storage1.hasGood(good)) {
                throw new IllegalArgumentException ("The Good the player want to leave is not in storage " + storageID1);
            }
        }
        // Check that the goods to leave are in the storage 2
        for (Good good : goods2to1) {
            if (!storage2.hasGood(good)) {
                throw new IllegalArgumentException ("The Good the player want to leave is not in storage " + storageID2);
            }
        }
        // Check that we can store the goods in the storage 1
        if (storage1.getGoodsCapacity() + goods1to2.size() < goods2to1.size()) {
            throw new IllegalArgumentException ("The storage " + storageID1 + " does not have enough space to store the goods");
        }
        // Check that we can store the goods in the storage 2
        if (storage2.getGoodsCapacity() + goods2to1.size() < goods1to2.size()) {
            throw new IllegalArgumentException ("The storage " + storageID2 + " does not have enough space to store the goods");
        }
        // Swap the goods
        ship.exchangeGood(goods2to1, goods1to2, storageID1);
        ship.exchangeGood(goods1to2, goods2to1, storageID2);

        List<Pair<Integer, List<Integer>>> convertedData = new ArrayList<>(
                List.of(
                        new Pair<>(storageID1, storage1.getGoods().stream().map(Good::getValue).toList()),
                        new Pair<>(storageID2, storage2.getGoods().stream().map(Good::getValue).toList())
                )
        );

        return new UpdateGoodsExchange(player.getUsername(), convertedData);
    }

    /**
     * Initializes the cannon strength for a player by calculating the base strength
     * and adding any purple alien bonus if present.
     *
     * @param player The player whose cannon strength is being initialized
     * @param cannonsStrength Map to store the calculated cannon strength for each player
     */
    static void initializeCannonStrengths(PlayerData player, Map<PlayerData, Float> cannonsStrength) {
        float initialStrength = player.getSpaceShip().getSingleCannonsStrength();
        if (player.getSpaceShip().hasPurpleAlien()) {
            initialStrength += player.getSpaceShip().getAlienStrength(false);
        }
        cannonsStrength.put(player, initialStrength);
    }

    /**
     * Initializes the engine strength for a player by calculating the base strength
     * and adding any brown alien bonus if present.
     *
     * @param player The player whose engine strength is being initialized
     * @param enginesStats Map to store the calculated engine strength for each player
     */
    static void initializeEngineStrengths(PlayerData player, Map<PlayerData, Float> enginesStats) {
        float initialStrength = player.getSpaceShip().getSingleEnginesStrength();
        if (player.getSpaceShip().hasBrownAlien()) {
            initialStrength += player.getSpaceShip().getAlienStrength(true);
        }
        enginesStats.put(player, initialStrength);
    }

    /**
     * Creates a pre-built spaceship configuration for testing or cheat purposes.
     * This method destroys existing components (except the main cabin) and places
     * a predefined set of components based on the specified ship index and game level.
     *
     * @param player The player whose spaceship will be modified
     * @param shipIndex The index of the predefined ship configuration to use
     * @param level The game level that determines which ship configurations are available
     * @return A list of events generated by the ship building process, including:
     *         - PlacedTileToSpaceship events for destroyed and placed components
     *         - PickedXFromBoard events for each component type placed
     *         - SetEngineStrength event if engines were placed
     *         - SetCannonStrength event if cannons were placed
     * @throws IllegalStateException if the requested ship configuration is not available for the given level
     * @throws IllegalArgumentException if an invalid ship index is provided
     */
    static List<Event> cheatShip(PlayerData player, int shipIndex, Level level) throws IllegalStateException, IllegalArgumentException {
        List<Event> events = new ArrayList<>();
        SpaceShip ship = player.getSpaceShip();
        Component component;
        String username = player.getUsername();

        int[] componentsIDs = new int[]{};
        int[][] componentsPositions = new int[][]{};
        int[] componentsRotations = new int[]{};

        // If the player had some components, destroy them (except the main cabin)
        for (int i = 0; i < SpaceShip.getRows(); i++) {
            for (int j = 0; j < SpaceShip.getCols(); j++) {
                if (ship.getComponent(i, j) != null && (i != 6 || j != 6)) {
                    ship.destroyComponent(i, j);
                    events.add(new PlacedTileToSpaceship(username, i, j));
                }
            }
        }

        if (level == Level.LEARNING) {
            switch (shipIndex) {
                case 0 -> {
                    componentsIDs = new int[]{
                            61, 125, 101, 96, 37,
                            62, 146, 10, 117, 18,
                            19, 30, 29, 90, 86,
                            41, 81
                    };

                    componentsPositions = new int[][]{
                            {5, 6}, {5, 5}, {5, 7}, {4, 6}, {6, 5},
                            {6, 4}, {6, 7}, {6, 8}, {7, 4}, {7, 5},
                            {7, 6}, {7, 7}, {7, 8}, {8, 4}, {8, 5},
                            {8, 7}, {8, 8}
                    };

                    componentsRotations = new int[]{
                            1, 0, 1, 0, 0,
                            1, 1, 3, 3, 0,
                            0, 0, 0, 0, 0,
                            1, 0
                    };
                }
                case 1 -> {
                    componentsIDs = new int[]{
                            40, 104, 147, 99, 33,
                            123, 37, 105, 19, 6,
                            82, 61, 24, 25, 95,
                            73, 81
                    };

                    componentsPositions = new int[][]{
                            {5, 6}, {5, 5}, {5, 7}, {4, 6}, {6, 5},
                            {6, 4}, {6, 7}, {6, 8}, {7, 4}, {7, 5},
                            {7, 6}, {7, 7}, {7, 8}, {8, 4}, {8, 5},
                            {8, 7}, {8, 8}
                    };

                    componentsRotations = new int[]{
                            1, 0, 0, 0, 0,
                            0, 0, 1, 1, 0,
                            0, 0, 0, 1, 0,
                            0, 0
                    };
                }
                case 2 -> {
                    throw new IllegalStateException("Ship to be built");
                }
            }
        } else {
            switch (shipIndex) {
                case 0 -> {
                    componentsIDs = new int[]{
                            139, 46,  137, 37,  48,
                            41,  133, 32,  77,  94,
                            65,  118, 28,  130, 14,
                            145, 16,  100
                    };

                    componentsPositions = new int[][]{
                            {6, 5}, {6, 4}, {7, 4}, {7, 5}, {7, 6},
                            {7, 7}, {6, 7}, {6, 8}, {8, 5}, {8, 4},
                            {8, 3}, {5, 6}, {5, 5}, {5, 7}, {7, 8},
                            {7, 9}, {8, 9}, {6, 9}
                    };

                    componentsRotations = new int[]{
                            2, 3, 1, 0, 0,
                            0, 2, 0, 0, 0,
                            2, 0, 2, 0, 0,
                            0, 1, 1
                    };
                }
                case 1 -> {
                    componentsIDs = new int[]{
                            126, 54,  115, 145, 103,
                            96,  107, 40,  24,  111,
                            61,  31,  98,  27,  19,
                            52,  118, 56,  5,   47,
                            1,   92,  93,  70,  78,
                            105
                    };

                    componentsPositions = new int[][]{
                            {5, 6}, {5, 5}, {5, 4}, {5, 7}, {5, 8},
                            {4, 5}, {4, 7}, {6, 5}, {6, 4}, {6, 3},
                            {6, 7}, {6, 8}, {6, 9}, {7, 3}, {7, 4},
                            {7, 5}, {7, 6}, {7, 7}, {7, 8}, {7, 9},
                            {8, 3}, {8, 4}, {8, 5}, {8, 7}, {8, 8},
                            {8, 9}
                    };

                    componentsRotations = new int[]{
                            0, 0, 3, 0, 1,
                            0, 3, 0, 1, 3,
                            1, 0, 0, 0, 1,
                            2, 2, 2, 0, 0,
                            0, 0, 0, 0, 0,
                            2
                    };
                }
                case 2 -> {
                    componentsIDs = new int[]{
                            111, 146, 102, 56, 131,
                            99, 100, 37, 38, 119,
                            6, 61, 105, 17, 47,
                            138, 78, 151, 18, 12,
                            147, 139, 73, 103, 92,
                            86
                    };

                    componentsPositions = new int[][]{
                            {5, 6}, {5, 5}, {5, 4}, {5, 7}, {5, 8},
                            {4, 5}, {4, 7}, {6, 5}, {6, 4}, {6, 3},
                            {6, 7}, {6, 8}, {6, 9}, {7, 3}, {7, 4},
                            {7, 5}, {7, 6}, {7, 7}, {7, 8}, {7, 9},
                            {8, 3}, {8, 4}, {8, 5}, {8, 7}, {8, 8},
                            {8, 9}
                    };

                    componentsRotations = new int[]{
                            0, 0, 0, 0, 1,
                            0, 1, 0, 0, 3,
                            0, 1, 1, 0, 0,
                            1, 0, 2, 2, 2,
                            2, 0, 3, 0, 0,
                            0
                    };
                }
                case 3 -> {
                    componentsIDs = new int[]{
                            97, 17,  115, 60,  131,
                            96, 100, 12,  146, 101,
                            6,  61,  105, 48,  6,
                            46, 25,  151, 18,  56,
                            73, 82,  95,  67,  92,
                            86
                    };

                    componentsPositions = new int[][]{
                            {5, 6}, {5, 5}, {5, 4}, {5, 7}, {5, 8},
                            {4, 5}, {4, 7}, {6, 5}, {6, 4}, {6, 3},
                            {6, 7}, {6, 8}, {6, 9}, {7, 3}, {7, 4},
                            {7, 5}, {7, 6}, {7, 7}, {7, 8}, {7, 9},
                            {8, 3}, {8, 4}, {8, 5}, {8, 7}, {8, 8},
                            {8, 9}
                    };

                    componentsRotations = new int[]{
                            0, 2, 3, 1, 1,
                            0, 1, 2, 0, 0,
                            0, 1, 1, 1, 0,
                            0, 1, 2, 2, 0,
                            0, 0, 0, 0, 0,
                            0
                    };
                }
                default -> throw new IllegalArgumentException("Invalid ship index: " + shipIndex);
            }
        }

        boolean isEngine = false, isCannon = false;
        for (int i = 0; i < componentsIDs.length; i++) {
            component = TilesManager.getTile(componentsIDs[i]);
            int[] connectors = new int[4];
            for (int j = 0; j < componentsRotations[i]; j++) {
                component.rotateClockwise();
            }
            ship.placeComponent(component, componentsPositions[i][0], componentsPositions[i][1]);

            for (int j = 0; j < 4; j++) {
                connectors[j] = component.getConnection(j).getValue();
            }

            if (component.getComponentType() == ComponentType.SINGLE_ENGINE ||
                    component.getComponentType() == ComponentType.DOUBLE_ENGINE) {
                isEngine = true;
            } else if (component.getComponentType() == ComponentType.SINGLE_CANNON ||
                    component.getComponentType() == ComponentType.DOUBLE_CANNON) {
                isCannon = true;
            }

            // Add the event based on the component type
            events.add(switch (component.getComponentType()) {
                case SINGLE_ENGINE, DOUBLE_ENGINE -> new PickedEngineFromBoard(username, componentsIDs[i], component.getClockwiseRotation(), connectors, ((Engine) component).getEngineStrength());
                case SINGLE_CANNON, DOUBLE_CANNON -> new PickedCannonFromBoard(username, componentsIDs[i], component.getClockwiseRotation(), connectors, ((Cannon) component).getCannonStrength());
                case CABIN -> new PickedCabinFromBoard(username, componentsIDs[i], component.getClockwiseRotation(), connectors);
                case STORAGE -> new PickedStorageFromBoard(username, componentsIDs[i], component.getClockwiseRotation(), connectors, ((Storage) component).isDangerous(), ((Storage) component).getGoodsCapacity());
                case BROWN_LIFE_SUPPORT, PURPLE_LIFE_SUPPORT -> new PickedLifeSupportFromBoard(username, componentsIDs[i], component.getClockwiseRotation(), connectors, component.getComponentType() == ComponentType.BROWN_LIFE_SUPPORT ? 1 : 2);
                case BATTERY -> new PickedBatteryFromBoard(username, componentsIDs[i], component.getClockwiseRotation(), connectors, ((Battery) component).getEnergyNumber());
                case SHIELD -> new PickedShieldFromBoard(username, componentsIDs[i], component.getClockwiseRotation(), connectors);
                case CONNECTORS -> new PickedConnectorsFromBoard(username, componentsIDs[i], component.getClockwiseRotation(), connectors);
            });
            events.add(new PlacedTileToSpaceship(username, componentsPositions[i][0], componentsPositions[i][1]));
        }

        if (isEngine) {
            SetEngineStrength engineStrength = new SetEngineStrength(player.getUsername(), ship.getDefaultEnginesStrength(), ship.getMaxEnginesStrength());
            events.add(engineStrength);
        }
        if (isCannon) {
            SetCannonStrength cannonStrength = new SetCannonStrength(player.getUsername(), ship.getDefaultCannonsStrength(), ship.getMaxCannonsStrength());
            events.add(cannonStrength);
        }

        return events;
    }
}
